# HTTPS와 SSL 인증서

### HTTPS와 SSL

HTTPS와 SSL을 같은 의미로 이해하고 있는 경우가 많다. 이것은 맞기도 틀리기도 하다. 그것은 마치 인터넷과 웹을 같은 의미로 이해하는 것과 같다. 결론적으로 말하면, 웹이 인터넷 위에서 돌아가는 서비스 중의 하나인 것처럼 HTTPS도 SSL 프로토콜 위에서 돌아가는 프로토콜이다. 즉, HTTPS로 데이터 전송을 시작할 때, SSL이 데이터 보안을 제공한다. 

### SSL(Secure Sockets Layer)과 TLS(Transport Layer Security)

일반적으로 네트워크상에서 데이터 혹은 신원에 대한 정보를 보호하기 위해서는 암호화 방식을 많이 사용한다. 그렇다면, 단순히 암호화한다고 해서 안전하다고 할 수 있을까? 그렇지 않다. 단순 암호화만을 통해 잘못 설계된 프로토콜의 경우는 재생(Replay)을 통해 공격당할 수 있다. 그 내용은 모르더라도 관찰된 통신 내용을 동일하게 재생하면 동일한 결과를 얻을 수 있는 것이다. 따라서, **단순한 암호화 외에 암호화 통신을 할 때 여러 가지 정보를 포함하여 암호화하는 것**이 보통이다. 우리는 보통 다른 사이트에 로그인할 때, 익숙한 아이디와 비밀번호를 통해 가입한다. 그래서 개인이 자주 사용하는 아이디와 비밀번호만 알면, 얼마든지 다른 사이트 해킹이 가능하다. 각 사이트는 이러한 특성을 알기 때문에 사이트마다 아이디와 비밀번호를 암호화시켜서 개인정보를 보호하도록 조치하고 있다. 이를 도와주는 것이 바로 SSL이다.

SSL이란 보안 소켓 계층 인증서로 종종 디지털 인증서로 불리며, 브라우저와 서버 사이의 암호화된 연결을 수립하는 데 사용됩니다. SSL은 **웹사이트와 브라우저 사이(또는 두 서버 사이)에 전송되는 데이터를 암호화하여 인터넷 연결을 보호하기 위한 표준 기술**입니다. 
TLS란 전송 계층 보안으로 SSL의 향상된, 더욱 안전한 버전을 말합니다. SSL이 더욱 일반적인 용어이기 때문에 DigiCert는 보안 인증서를 여전히 SSL로 언급하지만 DigiCert에서 SSL을 구입하면 가장 신뢰할 수 있는 최신 TLS 인증서를 얻을 수 있습니다. 
HTTPS는 하이퍼 텍스트 전송 프로토콜로, 웹사이트가 SSL/TLS 인증서로 보호되는 경우 HTTPS가 URL에 표시됩니다. 사용자는 브라우저 표시줄의 자물쇠 기호를 클릭해 발급 기관 및 웹사이트 소유자의 상호를 포함한 인증서의 세부 정보를 볼 수 있습니다. 

### SSL 인증서의 동작 원리

SSL 인증서는 SSL 핸드셰이크라는 과정을 통해 웹사이트/서버와 브라우저 간에 암호화된 연결을 수립합니다. 웹사이트 방문자에게는 이 과정이 보이지 않으며, 순간적으로 이루어집니다.

- 인증 : 사용자가 웹사이트에서 시작하는 모든 신규 세션에 대해 브라우저와 서버는 각각 다른 SSL 인증서를 교환하고 검증합니다.
- 암호화 : 서버는 브라우저와 `공개 키(public key)`를 공유하고, 이어서 브라우저는 이 키를 사용해 프리 마스터 키를 생성, 암호화합니다. 이를 `키 교환`이라고 합니다.
- 복호화 : 서버는 `개인 키(private key)`를 사용해 프리마스터 키를 복호화하고 세션 기간 동안 사용되는 암호화된 보안 연결을 수립합니다.

### SSL의 동작방법

SSL은 암호화 방식으로 두 가지 방식(공개키 방식, 대칭키 방식)을 혼합해서 사용한다. 

- *클라이언트와 서버가 주고 받는 실제 정보*는 **대칭키 방식**으로 암호화 
- *대칭키 방식으로 암호화된 실제 정보를 복호화할 때 사용할 대칭키*는 **비대칭키 방식**으로 암호화

### 대칭키 암호화 방식

이름에서 알 수 있듯, 어떤 정보를 암호화하거나 복호화할 때 사용하는 키가 동일한 경우를 말합니다. 암호화된 정보를 전달하고 확인하기 위해서 송/수신자가 둘 다 같은 키를 가지고 있어야 하기 때문에, 이러한 키를 안전하게 교환하는 것이 대칭키 암호화 방식의 가장 중요한 부분 중 하나입니다.

- 장점

공개키 방식보다 컴퓨팅 자원을 덜 사용한다.

- 단점

암호를 주고 받는 사람들 사이에 대칭키 전달이 어렵다는 점이다. 대칭키가 유출되면 키를 획득한 공격자는 암호화의 내용을 복호화 할 수 있기 때문에 암호가 무용지물이 되기 때문이다.

- 실습

```shell
echo 'this is the plain text' > plaintext.txt;
openssl enc -e -des3 -salt -in plaintext.txt -out ciphertext.bin;
```

1. enc -e -des3 : des3 방식으로 암호화 함.
2. -in plaintext.txt -out ciphertext.bin : plaintext.txt 파일을 암호화 한 결과를 ciphertext.bin 파일에 저장함.

```shell
openssl enc -d -des3 -in ciphertext.bin -out plaintext2.txt;
```

enc -d 옵션으로 인해서 ciphertext.bin 파일을 plaintext2.txt 파일로 복호화 한다는 의미이다.

### 공개키 암호화 방식 (비대칭키 암호화 방식)

어떠한 정보를 *암호화하거나 복호화할 때 사용하는 키가 서로 다른 경우*를 의미합니다. 또 아래 두 가지 경우로 나뉠 수 있다.

- 공개키(public key)로 정보를 암호화하는 경우
- 개인키(private key)로 정보를 암호화하는 경우

첫번째 경우는 비공개키는 자신만 가지고 있고 공개키를 타인에게 제공한다. 공개키를 제공 받은 타인은 이를 통해 정보를 암호화한다. 암호화한 정보를 비공개키를 가지고 있는 사람에게 전송한다. `비공개키의 소유자는 이 키를 이용해서 암호화된 정보를 복호화한다`. 이 과정에서 공개키가 유출되더라도 비공개키를 모르면 정보를 복호화할 수 없기 때문에 안전하다. `공개키로는 암호화는 할 수 있지만, 복호화는 할 수 없기 때문이다`.

두번째 경우는 첫번째 용례를 응용한 것이다. 먼저, 비공개키의 소유자는 비공개키를 이용해서 정보를 암호화 한 후에 공개키와 함께 암호화된 정보를 전송한다. 정보와 공개키를 획득한 사람은 공개키를 이용해서 암호화된 정보를 복호화 한다. 이 과정에서 공개키가 유출된다면 의도하지 않은 공격자에 의해서 데이터가 복호화 될 위험이 있다. 이런 위험에도 불구하고 비공캐를 이용해서 암호화하는 이유는 데이터를 보호하는 것이 목적이 아니기 때문이다. 암호화된 데이터를 공개키를 가지고 복호화 할 수 있다는 것은 그 데이터가 공개키와 쌍을 이루는 비공개키에 의해서 암호화 되었다는 것을 의미한다. 즉, 공개키가 데이터를 제공한 사람의 신원을 보장해주게 되는 것이다. 이러한 것을 **전자 서명**이라고 한다.

- 장점

공개된 키가 유실되더라도 복호화할 수 없다는 장점이 있다.
클라이언트는 서버에게 자신의 공개키를 전송하고, 서버는 클라이언트에게 자신의 공개키를 전송한다.
서버는 데이터를 받아서, 자신이 받은 공개키로 복호화하면 될 수 있다. 비밀키의 소유자가 아니라면 복호화(decryption)할 수 없다.
비밀번호가 노출되지 않는다는 장점이 있다.

- 단점

공개키 방식은 암호화하고 복호화하는 과정에서 컴퓨팅 자원을 많이 사용한다.

- 실습

아래에 사용되는 RSA란 공개키 암호시스템의 하나로, 암호화뿐만 아니라 전자서명이 가능한 최초의 알고리즘으로 알려져 있다.

```shell
openssl genrsa -out private.pem 1024
```

비공개키에 대한 *public.pem*이라는 이름의 공개키를 생성한다. 이 공개키를 자신에게 정보를 제공할 사람에게 전송하면 된다.

```shell
openssl rsa -in private.pem -out public.pem -outform PEM -pubout
```

공개키를 가진 사람이 어떤 정보를 비공개키를 가지고 있는 사람에게 전송하는 상황을 상정해보자. 아래는 coding everybody란 이름의 문자를 담고 있는 file.txt를 만든다. 이 데이터를 비공개키 소유자에게 전송하기 위해선 암호화 과정을 거친다.

```shell
echo 'coding everybody' > file.txt
```

file.txt를 암호화 해보자. 아래의 예제는 file.txt의 내용을 RSA방식으로 암호화한 file.ssl이라는 이름의 파일을 생성한다. 이 때 사용된 공개키가 *public.pem*이다. 이제 안심하고 file.txt를 암호화한 결과인 file.ssl을 비공개키의 소유자에게 전송할 수 있다.

```shell
openssl rsautl -encrypt -inkey public.pem -pubin -in file.txt -out file.ssl
```

그럼 file.ssl을 수신받은 비공개키 소유자가 어떻게 이 정보를 복호화 할 수 있는지 알아보자. 아래 예제는 file.ssl을 복호화한 결과를 decrypted.txt로 만들어내는 방법을 보여준다. 이 과정에서 비공개키인 private.pem을 사용했다.

```shell
openssl rsautl -decrypt -inkey private.pem -in file.ssl -out decrypted.txt
```

컴퓨터와 컴퓨터가 네트워크를 이용해서 통신을 할 때는 내부적으로 3가지 단계가 있다. `악수 -> 전송 -> 세션종료.`

### 악수 (handshake)

사람이 인사를 통해서 상대의 기분과 상황을 탐색하는 것처럼, 클라이언트와 서버도 실제 데이터를 주고 받기 전에 클라이언트와 서버는 일종의 인사인 Handshake를 한다.
SSL 방식을 이용해서 통신을 하는 브라우저와 서버는 HandShake를 한다.

1. 클라이언트가 서버에 접속한다. 이 단계를 Client Hello라고 한다. 그리고 아래와 같은 데이터를 주고 받는다.

- 클라이언트 측에서 생성한 랜덤 데이터 
- 클라이언트가 지원하는 암호화 방식들 
- 세션 아이디 

2. 서버는 Client Hello에 대한 응답으로 Server Hello를 하게 된다.

- 서버 측에서 생성한 랜덤 데이터 
- 서버가 선택한 클라이언트의 암호화 방식 
- 인증서 

3. 클라이언트는 서버의 인증서가 CA(Certificate Authority)에 의해서 발급된 것인지를 확인하기 위해서 클라이언트에 내장된 CA 리스트를 확인한다. 인증서가 CA에 의해서 발급된 것인지 확인하기 위해서 클라이언트에 내장된 CA의 공개키를 이용해서 인증서를 복호화한다. 복호화에 성공했다면 인증서는 CA의 개인키로 암호화된 문서임이 암시적으로 보증된다. 인증서를 전송한 서버를 믿을 수 있게 된 것이다.
4. 서버는 클라이언트가 전송한 `pre master secret` 값을 자신의 비공개키로 복호화한다. 이로써 서버와 클라이언트가 모두 pre master secret 값을 공유하게 되었다. 그리고 서버와 클라이언트는 모두 일련의 과정을 거쳐서 `pre master secret` 값을 `master secret` 값으로 만든다. master secret는 session key를 생성하는데 이 session key 값을 이용해서 서버와 클라이언트는 데이터를 대칭키 방식으로 암호화 한 후에 주고 받는다.
5. 클라이언트와 서버는 핸드쉐이크 단계의 종료를 서로에게 알린다.

### 세션

실제로 서버와 클라이언트가 데이터를 주고 받는 단계를 말한다. 정보를 상대방에게 전송하기 전에 session key 값을 이용해서 대칭키 방식으로 암호화한다. 암호화된 정보는 상대방에게 전송될 것이고, 상대방도 세션키 값을 알고 있기 때문에 암호를 복호화할 수 있다.
대칭키와 공개키를 조합해서 사용하는 이유는 공개키 방식이 많은 컴퓨터 자원을 사용하기 때문입니다. 만약 공개키를 그대로 사용하면 많은 접속이 몰리는 서버는 매우 큰 비용을 지불해야 합니다. 반대로 대칭키는 암호를 푸는 열쇠인 대칭키를 상대에게 전송해야 하는데, 암호화 되지 않은 인터넷을 통해서 키를 전송하는 것은 위험하기 때문입니다. 그래서 속도는 느리지만 데이터를 안전하게 주고 받을 수 있는 공개키 방식으로 대칭키를 암호화하고 실제 데이터를 주고 받을 때는 대칭키를 이용해서 데이터를 주고 받습니다.

### 세션종료

데이터의 전송이 끝나면 SSL 통신이 끝났음을 서로에게 알려준다.

# CA를 통해서 인증서 생성

CA를 통해서 인증서를 구입해서 사용하려면 여러 기관 중 한 곳을 선택해야 한다. 필자가 선택한 CA는 이스라엘 기업인 StarCom이다. 이 회사는 1년간 무료로 사용할 수 있는 인증서를 제공한다. 인증서 구입에 부담이 있는 개인이나 작은 사업자라면 만족할만한 보안을 제공하는 것으로 알려져있다. 이 회사에서 제공하는 무료 인증서는 아래와 같은 기능을 제공한다.

웹서버 인증서 (SSL/TLS)
Client 와 mail 인증서 (S/MIME)
128/256-bit 암호화
US $ 10,000 보상금
1년간 유효함

1. 로그인 페이지로 이동한다.
2. Express Lane 옵션을 선택한다.
3. 요구하는 정보를 '사실대로' 입력한다. 만약 허위 정보가 입력되면 가입 승인이 거부된다.
4. 이메일로 인증코드가 반송된다. 이메일을 확인한다.
5. 필자는 이런 내용의 이메일을 받았다.
6. 한국어로 번역하면 아래와 같다.
7. 아래와 같이 답변한다.
8. 그럼 인증에 성공했다는 메시지가 도착할 것이다.
9. 위의 주소로 \*\*\*로 표시한 부분이 자신의 인증코드다. 인증코드를 복사한 후에 링크를 클릭해보자. 아래와 같은 메시지가 출력될 것이다. 인증코드를 붙여넣기 한다.
10. 비공개키의 암호화 방식을 지정한다. 2048을 사용하자.
11. install 버튼을 누른다.
12. 축하 메시지가 출력되면 인스톨에 성공한 것이다.
13. 도메인 주소를 입력한다.
14. 인증 메일을 선택한다.
15. 수신 받은 이메일을 확인한다.
16. \*\*\* 표시된 텍스트를 복사해서 Vertification Code 필드에 입력한다.
17. 아래와 같은 화면이 출력된다면 인증에 성공한 것이다.
18. 비공개키를 발급 받는다.
19. 비공개키를 복사한다.
20. 도메인을 추가한다.
21. 인증서 발급을 위한 모든 정보의 입력이 끝났다. Continue를 누른다.
22. 인증서가 발급되었다.

# 웹서버 셋팅

1. 아파치(apache)를 설치한다.

```shell
sudo apt-get install apache2;
```

2. 아파치의 SSL 모듈을 활성화 한다.

```shell
sudo a2enmod ssl
```

3. 아파치를 재시작 한다.

```shell
sudo service apache2 restart
```

4. SSL 인증서 관련된 파일을 위치시킬 디렉토리를 만든다.

```shell
sudo mkdir /etc/apache2/ssl
```

5. /etc/apache2/ssl 디렉토리에 인증서 파일들을 위치시킨다.

6. 보안을 위해서 디렉토리와 파일의 권한을 조정한다.

```shell
sudo chown -R root:root /etc/apache2/ssl;
```

```shell
sudo chmod 600 /etc/apache2/ssl/*.*
```

```shell
sudo chmod 700 /etc/apache2/ssl;
```

7. **virtualhost를 설정한다.** 하나의 웹서버에서 여러개의 서비스를 도메인 별로 운영할 수 있도록 돕는 apache의 기능이다. 기본 설정 파일인 **/etc/apache2/sites-available/default-ssl**을 수정한다. 아래에서는 편집기로 nano를 사용하고 있다.

```shell
sudo nano /etc/apache2/sites-available/default-ssl
```

8. 파일의 내용에서 지시자의 값을 아래와 같이 변경한다. 예제 파일은 http://www.startssl.com/?app=21를 참고한다.

```shell
SSLCertificateFile    /etc/apache2/ssl/ssl.crt
SSLCertificateKeyFile /etc/apache2/ssl/ssl.key
SSLCertificateChainFile /etc/apache2/ssl/sub.class1.server.ca.pem
SSLCACertificateFile /etc/apache2/ssl/ca.pem
```

9. 버추얼 호스트 default-ssl을 활성화된 서비스로 등록한다.

```shell
sudo a2ensite default-ssl
```

10. apache를 재시작한다.
11. https 프로토콜로 접속한다.

# 참고한 사이트

[https://universitytomorrow.com/22](https://universitytomorrow.com/22)
[https://www.youtube.com/watch?v=8R0FUF_t_zk](https://www.youtube.com/watch?v=8R0FUF_t_zk)
[https://opentutorials.org/course/228/4894](https://opentutorials.org/course/228/4894)
[https://www.digicert.com/kr/what-is-ssl-tls-and-https](https://www.digicert.com/kr/what-is-ssl-tls-and-https)
