# 29cm의 MSA 전환기

### 구성원 설득하기

- MSA 전환의 장점
  - 기존보다 좀 더 빠른 속도로 시장의 변화에 대응할 수 있게 된다.
    - 비즈니스 도메인을 중심으로 시스템을 분리하기 때문에, 각 시스템을 운영하고 관리하는 각 팀마다 각자의 목표와 속도로 운영이 가능하게 된다.
    - 다른 도메인 서비스와 관계없이 독립적인 배포가 가능하므로, 각 도메인 별로 비즈니스 대응 속도를 향상시킬 수 있게 된다.

### MSA 전환 과정에서 중요한 점

- MSA 전환의 장점을 팀과 구성원들에게 증명하는 시간이 필요하다.
- MSA 가치를 빠르게 증명할수록 향후 MSA 전환에 필요한 여러가지 자원을 충분히 받을 가능성이 커진다.
- 높은 품질의 코드를 비교적 빠른 시간 안에 구현하여 실제 운영에 배포하는 것이 정말 중요함.

### MSA를 고려해봐야 하는 경우

모놀리식 구조의 코드 베이스가 커지면, 신규 기능을 배포하였을 때 문제가 발생될 가능성이 높아진다.

- 배포 직후 예상치 못한 부분에서 시스템 버그가 발생되는 경우가 많을 때.
- 테스트 해야 할 기능이 많기 때문에 2주 단위의 정기배포 절차가 존재했었음. 그렇기 떄문에 빠른 기능 런칭이 이뤄지지 않았음.
- 구성원들은 굵직한 feature 개발에 대한 부담감을 가지고 있었음.
- 대형 이벤트가 있을 때마다 간헐적인 시스템 장애가 발생했었음.

### 점진적으로 MSA 전환 과정

- 주요 도메인의 주요 기능부터 점진적으로 이관하면 전환이 완료될때 마다 성과 측정이 가능하고 속도도 빠르다.
- **스트랭글러 패턴**을 사용한다.
  - 시스템 구조를 변경할 때 기존 시스템과 신규 시스템에 유입되는 트래픽을 조절하면서 점진적으로 신규 시스템 쪽으로의 트래픽을 늘려가는 과정이 필요하다.
  - Routing을 통해 10분의 1 정도의 트래픽만 MSA 서비스에서 실제로 테스트해본다.
  - 기존 시스템과 신규 시스템이 완전히 동일하게 동작함을 확인하면, 서서히 신규 시스템으로 전달되는 트래픽을 늘려나간다.
- 처음부터 데이터베이스 분리를 고려하지 않아도 된다.
- 온전한 msa 전환에서는 각 서비스마다 각자의 데이터베이스를 가지는 것이 맞다.
- 하지만 점진적인 방식으로 전환을 진행할 때의 장점을 생각한다면, 우선 코드를 분리한 후 데이터베이스를 분리하는 게 좋다.

### 데이터베이스 분리

1. 해야 하는 이유

- 진정한 MSA를 완성하려면 각 데이터베이스를 가지고 있어야 한다.
  - 하나의 DB를 여러 도메인 서비스가 함께 사용하는 구조를 유지한다면 (shared database), 해당 DB가 다운되거나 성능 상의 이슈가 발생할 때 관련 서비스 모두가 영향을 받는 문제가 발생하게 된다. (SPOF)

2. 방법 : 점진적으로 해야 한다.

- 점진적인 방식으로 전환을 진행할 때의 장점을 생각한다면, 코드를 나누고 데이터베이스를 분리하는 것이 맞다.
  - 즉, monolithic과 분리된 msa 서비스가 하나의 데이터베이스를 공유하며 사용하는 것이다.
- 한번 코드를 분리하게 되면 해당 코드가 사용하는 데이터가 무엇인지 확인할 수 있고 이를 기반으로 추후 데이터베이스 분리 작업도 수월하게 진행할 수 있다.

3. 진행과정

- 모든 서비스가 함께 사용하는 기존 DB에서 특정 도메인을 위한 일부 DB를 분리할 때의 절차는 다음과 같다.
  - 새로운 DB로 대상 데이터를 일괄로 복제한다.
  - 기존 DB와 신규 DB를 바라보는 배치 로직을 구현한다.
  - 해당 배치는 양쪽 DB를 보면서 createdAt, updatedAt과 같은 시간을 기준으로 지속적인 데이터 동기화를 수행한다.
  - 기존 DB에서 데이터가 추가되거나 변경될 때, 신규 DB에도 데이터 변경분이 반영되도록 한다.
- 기존 DB와 신규 DB 양쪽에 데이터를 write 하도록 도메인 서비스를 개발 후 배포한다 (dual-write).
  - 도메인 서비스에서 데이터 변경 작업을 진행할 때, 양쪽 DB에 모두 반영되도록 로직을 개발한다.
    - 이 때, 신규 DB에는 데이터 쓰기 작업만 수행하고 로직 처리를 위한 읽기, 쓰기 작업은 기존 DB에서 처리한다.
    - 그렇기 때문에 신규 DB에서의 데이터 쓰기에 문제가 있더라도 전체 로직 처리에는 영향이 없다 (없어야 한다).
  - 이는 이후의 모든 트래픽을 신규 DB로 온전히 처리하기 위한 사전 작업이다.
  - 배포 후 기존 DB와 신규 DB에 쌓이는 데이터를 비교하면서 전체 로직의 정합성을 체크할 수도 있다.
- 신규 DB에 쌓이는 데이터 정합성에 문제가 없다면, 도메인 서비스의 트래픽 처리는 신규 DB에서 이루어지게끔 로직을 변경 배포한다.
  - 신규 DB에서 모든 트래픽을 처리하는 과정에 이슈가 없다면 기존 DB는 일정 시점 후에는 제거할 수 있게 된다.
  - 물론 이슈가 발견된다면 기존 DB에서 트래픽을 처리하도록 빠르게 롤백하거나 유입되는 트래픽을 전환하면 된다.

### 현실적인 리팩토링

- 기존 코드에서 외부 동작의 변경 없이 내부의 코드 구조를 개선하는 작업을 리팩토링이라고 한다.
  - 시스템을 이용하는 외부에서는 리팩토링의 전과 후의 차이를 인식할 수 없어야 한다.
- 리팩토링 과정에서 **필수적으로 필요한 것은 리팩토링 전과 후의 동작이 동일함을 보장**하는 `테스트 코드`이다.
  - 그렇기 때문에 성공적인 리팩토링을 위해서는 어떻게든 실용적인 테스트 코드를 확보하는 것이 중요하다.
- 오래된 monolithic 기반의 코드일수록 잘 작성되고 활용 가능한 테스트 코드가 없거나 많이 부족한 것이 현실이다.
  - 테스트 코드의 작성을 위해서는 해당 기능에 input, output, process 등을 정확히 파악해야 한다.
  - 그렇기 때문에 해당 서비스에 대한 상세한 로그 확보가 필수적이다.
- 리팩토링의 필요성을 내부 구성원에게 정확히 설명하고 납득시키는 것도 중요하다.

### 개선안

- HTTP to gRPC

MSA는 네트워크로 연결된 서비스 간의 통신을 기반으로 운영되는 분산 아키텍처이므로 서비스 간 통신 매커니즘에 대한 정의와 적용 결정은 중요하다.
동기식 요청 응답 방식과 비동기식 이벤트 방식으로 구분

- 동기식 요청 응답 방식은 클라이언트가 서버에게 요청을 보내고 응답을 기다리는 패턴이고
- 비동기식 이벤트 방식은 이벤트 브로커를 통해 메세지를 비동기적으로 전달하는 패턴이다.

메시지 포맷으로 구분한다면 텍스트 기반의 포맷과 바이너리 기반의 포맷으로 나뉜다.

- JSON이나 XML 같은 텍스트 기반의 포맷
- gRPC와 같이 통신 속도가 매우 빠른 바이너리 기반의 포맷

통신 매커니즘과 메시지 포맷에 따라 각각의 장단점이 존재하는데 서비스에 따른 요구사항에 따라 각기 다른 선택이 가능하다.

- HTTP API (REST API)
  - 장점 : 단순하고 개발자들에게 익숙하다.
  - 단점 : 요청과 응답이 동기식이므로 API 호출 과정에서 양쪽 서버가 모두 실행 중이어야 한다.
- gRPC
  - 장점 : 바이너리 기반의 메시지 포맷을 가지기 때문에 HTTP API에 비해 통신 속도가 매우 빠르다. 프로토콜 버퍼를 통한 통신 과정에서의 데이터 타입을 명확하게 정의할 수 있다.
  - 단점 : 웹 브라우저와 같은 외부 클라이언트에서 gRPC 사용은 충분히 지원되지 않고 있다. 학습 비용이 있다.
- 브로커 기반의 비동기 메시징
  - 장점 : 메세지 브로커에 메시즈를 읽고 전달하기만 하면 되므로 서버 간의 정확한 위치를 알 필요가 없다. 메시지 브로커가 존재하기 때문에 메시지 처리에 대한 버퍼링이 가능하다.
  - 단점 : 메시지 브로커에 대한 운영 경험이 필요하다. 메시지 브로커가 다운되면 관련 서비스 전체에 장애가 발생한다.

### 질문사항

1. 기존 DB와 신규 DB를 바라보는 배치 로직을 구현한다는 게 무슨 말인가?
2. KAFKA란 무엇인가?
