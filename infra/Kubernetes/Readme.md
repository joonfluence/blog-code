# 서론

# 본론

### 전통적인 배포 시대

- 초기 조직은 애플리케이션을 물리 서버에서 실행했었다. 한 물리 서버에서 여러 애플리케이션의 리소스 한계를 정의할 방법이 없었기에, 리소스 할당의 문제가 발생했다. 예를 들어 물리 서버 하나에서 여러 애플리케이션을 실행하면, 리소스 전부를 차지하는 애플리케이션 인스턴스가 있을 수 있고, 결과적으로 다른 애플리케이션의 성능이 저하될 수 있었다. 이에 대한 해결책은 물리적인 서버를 여러 개 두는 것이지만, 각 리소스가 충분히 활용되지 않는다는 점에서 확장 가능하지 않았으므로, 물리 서버를 유지하는 데 많은 비용이 소모되었다.

### 가상화된 배포 시대

- 단일 물리 서버의 CPU에서 여러 가상 시스템을 실행할 수 있게 한다. 가상화를 사용하면 VM간에 애플리케이션을 격리하고 애플리케이션의 정보를 다른 애플리케이션에서 자유롭게 액세스 할 수 없으므로, 일정 수준의 보안성을 제공할 수 있다. 가상화를 사용하면 물리 서버에서 리소스를 보다 효율적으로 활용할 수 있으며, 쉽게 애플리케이션을 추가하거나 업데이트할 수 있고 하드웨어 비용을 절감할 수 있어 더 나은 확장성을 제공한다. 가상화를 통해 일련의 물리 리소스를 폐기 가능한 가성머신으로 구성된 클러스터로 만들 수 있다.

### 컨테이너 개발 시대

- 컨테이너는 VM과 유사하지만 격리 속성을 완화하여 애플리케이션 간에 운영체제를 공유한다 그러므로 컨테이너는 가볍다고 여겨진다. VM과 마찬가지로 컨테이너에는 자체 파일 시스템, CPU 점유율, 메모리, 프로세스 공간 등이 있다. 기본 인프라와의 종속성을 끊었기 때문에, 클라우드나 OS 배포판에 모두 이식할 수 있다.

### 컨테이너 개발의 장점

- 기민한 애플리케이션 생성과 배포 : VM 이미지를 사용하는 것에 비해 **컨테이너 이미지 생성이 보다 쉽고 효율적**임.
- 지속적인 개발, 통합 및 배포 : 안정적이고 주기적으로 컨테이너 이미지를 빌드해서 배포할 수 있고 (이미지의 불변성 덕에) 빠르고 효율적으로 롤백할 수 있음.
- 개발과 운영의 관심사 분리 : 배포 시점이 아닌 빌드/릴리즈 시점에 애플리케이션 컨테이너 이미지를 만들기 때문에, 애플리케이션이 인프라스트럭쳐에서 분리된다.
- 가시성 : OS 수준의 정보와 메트릭에 머무르지 않고, 애플리케이션의 헬스와 그 밖의 시그널을 볼 수 있다.
- 개발, 테스팅 및 운영 환경에 걸친 일관성 : 랩탑에서도 클라우드에서와 동일하게 구동된다.
- 클라우드 및 OS 배포판 간 이식성 : Ubuntu, RHEL, CoreOS, 온-프레미스, 주요 퍼블릭 클라우드와 어디에서든 구동된다.
- 애플리케이션 중심 관리 : 가상 하드웨어 상에서 OS를 실행하는 수준에서 논리적인 리소스를 사용하는 OS 상에서 추상화 수준이 높아진다.
- 느슨하게 커플되고, 분산되고, 유연하며, 자유로운 마이크로서비스 : 애플리케이션은 단일 목적의 머신에서 모놀리식 스택으로 구동되지 않고 보다 작고 독립적인 단위로 쪼개져서 동적으로 배포되고 관리될 수 있다.
- 자원 사용량: 리소스 사용량: 고효율 고집적.

### 쿠버네티스가 왜 필요하고 무엇을 할 수 있을까?

컨테이너는 애플리케이션을 포장하고 실행하는 좋은 방법이다. 프로덕션 환경에서는 애플리케이션을 실행하는 컨테이너를 관리하고 가동 중지 시간이 없는지 확인해야 한다. 예를 들어, 컨테이너가 다운되면 다른 컨테이너를 다시 시작해야 한다. 이 문제를 시스템에 의해 처리한다면 더 쉽지 않을까?
그것이 쿠버네티스가 필요한 이유다. 쿠버네티스는 분산 시스템을 탄력적으로 실행하기 위한 프레임워크를 제공한다. 애플리케이션의 확장과 장애 조치를 처리하고, 배포 패턴 등을 제공한다.

- 서비스 디스커버리와 로드밸런싱
- 스토리지 오케스트레이션
- 자동화된 롤아웃과 롤백
- 자동화된 빈 패킹
- 자동화된 복구
- 시크릿과 구성 관리

### 환경설정

- 맥에서의 설치 방법

```bash
brew install kubectl
```

- 버젼 확인

```bash
kubectl version --client
```

- 구성 확인
    - 랩톱에서 로컬로 쿠버네티스 클러스터를 실행하려면, **Minikube**와 같은 도구를 먼저 설치한 다음 위에서 언급한 명령을 다시 실행해야 한다.

```bash
kubectl cluster-info
```

- 자세한 구성 정보 확인

```bash
kubectl cluster-info dump
```


# 참고한 사이트

[https://kubernetes.io/ko/docs/concepts/overview/](https://kubernetes.io/ko/docs/concepts/overview/)